"""This modules deals with the daunting task of generating geometries"""

# import sys
import os
import logging
# from pathlib import Path

import random
import numpy as np

from pathlib import Path

from ase import Atoms
# from ase.calculators.espresso import Espresso
from ase.build import nanotube
from ase.build import molecule
from ase.constraints import FixAtoms
from ase.build.attach import attach
# from ase.visualize import view

from ase.io import write
from ase.io import read


import calculeitors
import utils

from config import config
# import config

# TODO: Implement this module
# - Probably better in its own directory:
#   - One file for nanotubes
#   - one file for surfaces
#   - one file for crystals (including defects)
#   - one file for laminar materials
#   - one file for molecules and conformers

#   M: gengeom
def generate_geometry_with_packmol():
    """
    Generate geometry using PACKMOL via mdapackmol and MDAnalysis to
    preserve the topology after Packmol
    """
    import MDAnalysis as mda
    import mdapackmol

    import warnings

    # Read required config info
    molec = config.molec
    n_molecules = config.n_molecules
    tolerance = config.tolerance
    cnt_gap = config.cnt_gap
    random_seed = config.random_seed
    # seed = config.seed

    cnt_file = 'cnt_byFillMyTubes.pdb'
    mol_file = 'mol_byFillMyTubes.pdb'

    # Generate the Nanotube and the molecules
    cnt = create_nanotube()
    cnt.center(vacuum=cnt_gap/2, axis=(0, 1))
    write(cnt_file, cnt)
    # write('cnt_byFillMyTubes.xyz', cnt)
    mmol = molecule(molec)
    mmol.center()
    write(mol_file, mmol)
    # write('mol_byFillMyTubes.xyz', mmol)
    cell_parameters = utils.get_parameter_from_pdb(cnt_file, 'CRYST1')

    # Get ranges for PACKMOL
    cnt_xyz = cnt.get_positions()
    min_x, max_x = min(cnt_xyz[:, 0]), max(cnt_xyz[:, 0])
    min_y, max_y = min(cnt_xyz[:, 1]), max(cnt_xyz[:, 1])
    min_z, max_z = min(cnt_xyz[:, 2]), max(cnt_xyz[:, 2])

    cnt_z_length = max_z - min_z
    cnt_x_diameter = (max_x - min_x)/2
    cnt_y_diameter = (max_y - min_y)/2

    cnt_diameter = (cnt_x_diameter + cnt_y_diameter)/2

    # cell_z = cnt.get_cell()[2][2]

    # load individual molecule files into MDAnalysis Universe
    _cnt = mda.Universe(cnt_file)
    # _cnt = mda.Universe('cnt_byFillMyTubes.xyz')

    _molecule = mda.Universe(mol_file)
    # _molecule = mda.Universe('mol_byFillMyTubes.xyz')

    # This is confusing, but if we want to recreate the Packmol geometries we need to pass a
    # different seed each time generated with the seed we gave to FillMyTubes
    if random_seed == False:
        seed = random.randint(1, 2**16-2)
    else:
        seed = -1

    # call Packmol with MDAnalysis objects as arguments
    # the 'instructions' allow for any valid Packmol commands, one per line
    with warnings.catch_warnings():   # Ignore some MDAanalysis warnings
        warnings.simplefilter('ignore')
        system = mdapackmol.packmol(
            [mdapackmol.PackmolStructure(
                _cnt, number=1,
                instructions=[f'fixed 0. 0. {cnt_z_length/2} 0. 0. 0.', 'center']),
                mdapackmol.PackmolStructure(
                _molecule, number=n_molecules,
                instructions=[f'inside cylinder 0. 0. 0. 0. 0. 1. {cnt_diameter-0.05} {cnt_z_length-tolerance/3}'])],
            tolerance=tolerance,
            seed=seed
        )

    # We do not need MDAnalysis Universe at the moment, we want ASE Atoms
    # so we read the geometry generated by packmol again with ASE

    # First we need to add the cell parameters that are missing after packmol
    utils.insert_line_in_pdb('output.pdb', cell_parameters[:-1], 5)
    # Read the output generated by Packmol
    system = read('output.pdb')

    # Clean up and sort out the mess
    for f in [cnt_file, mol_file, 'packmol.stdout', 'output.pdb']:
        try:
            os.remove(f)
        except FileNotFoundError:
            pass

    return system

#   M: gengeom
def create_nanotube():
    """Clue: Creates a ...

    Parameters
    ----------
    n,m and lenght are taken from the config file

    Returns
    -------
    a carbon nanotube (ase Atom object)
    """

    n, m, lenght = config.cnt_n, config.cnt_m, config.cnt_l
    bond_lenght = config.cnt_bond
    constraints = config.cnt_constraints

    cnt = nanotube(n, m, length=lenght, bond=bond_lenght)

    # mask = [atom.symbol == 'C' for atom in cnt]
    if constraints == 'all':
        constraints = FixAtoms(mask=[atom.symbol == 'C' for atom in cnt])
        cnt.set_constraint(constraints)   # Lost afater PACKMOL
        # TODO: Get coordinates of atoms with constraints, and create a function
        # to apply the constraints again after Packmol

    # ------------------------
    # WORK OUT THE CONSTRAINTS
    # ------------------------
    # NOTE: Sorry for the mess below... A more flexible way of adding
    # constraints will be useful, but it may take some time before is
    # implemented. I keep this here for the future...

    # Apply constraints based on a radial distance to the z axis of the CNT
    # If the distance between the longitudinal axis Z and the x,y coordintes is
    # bigger than 95% of the radius of the the CNT, then fix the atom

    # system_cto = cnt.get_center_of_mass()       # center of Mass of the CNT
    # cnt_atom =  cnt.get_positions()[1]          # take a random atom of the CNT
    # r = get_xy_distance(system_cto, cnt_atom)   # radi of the CNT

    #   loop over atom:        _/---------------------------------------\_
    # mask = [get_xy_distance(atom.position, system_cto) >= r*0.95 for atom in system]
    #         |------------------condicion-----------------------|
    #
    # constraints = FixAtoms(mask=mask)
    # system.set_constraint(constraints)

    return cnt


# M: gengeom
# TODO:
# Move manipulation functions out of this function so I can use it to manipulate
# individual geometries so we can pass to PACKMOL molecules in the desired orientation.
#   - My be useful when placing molecules outside the nanotube or on surfaces.
def add_molecules(cnt):
    """ Add ONLY the molecules along the Z axis of the nanotube
    Does not add the nanotube itself

    Parameters
    ----------
      - cnt: nanotube

    Returns
    -------
      -  Molecules along the Z axis of the cnt, rotated and displaced according
         to the input parameters
    """
    # Get the parameters from config object
    molec = config.molec
    n_molecules = config.n_molecules
    compresion_factor = config.compresion_factor
    rot_x = config.molec_rot_x
    rot_y = config.molec_rot_y
    rot_z = config.molec_rot_z

    rot_axis = config.molec_rot_axis

    def rotate_molecule(molecule, axis=['x', 'y', 'z']):
        for ax in axis:
            if ax == 'x':
                molecule.rotate(get_rotation_angle(rot_x), 'x')
            if ax == 'y':
                molecule.rotate(get_rotation_angle(rot_y), 'y')
            if ax == 'z':
                molecule.rotate(get_rotation_angle(rot_z), 'z')

    def get_rotation_angle(angle):
        if angle is None:
            return 0
        if isinstance(angle, dict):
            return random.uniform(angle['min'], angle['max'])
        else:
            return angle

    # It will arrange the molecules along the Z axis of the CNT
    if n_molecules > 0:
        molecular_distance_z = (
            cnt.get_cell()[2][2])/(n_molecules) * compresion_factor
        print('molecular distance', molecular_distance_z)

    rotate = rot_x or rot_y or rot_z

    molecules = Atoms()
    # Add molecules
    for m in range(0, n_molecules):
        mmol = molecule(molec)
        if rotate:
            rotate_molecule(mmol, rot_axis)
        if m == 0:
            # TODO: Add parameters to control displacement
            if True:
                # Displace the first molecule
                displace = [0, 0, molecular_distance_z * random.random()]
                mmol.translate(displace)
            molecules = mmol

        else:
            molecules = attach(molecules, mmol,
                               distance=molecular_distance_z,
                               direction=(0, 0, 1))
    return molecules


#   M: gengeom
def set_cell(system):
    """Set the cell parameter of the system

    Parameters
    ----------
    System: (ASE Atoms)

    Returns
    -------
        Returns nothing. It modifies the system itself
    """
    # if system = cnt:
    cnt_gap = config.cnt_gap
    system.center(vacuum=cnt_gap/2, axis=(0, 1))

    # OLD Manual Way
    # # Get the limits of the CNT
    # cnt_xyz = cnt.get_positions()
    # min_x, max_x = min(cnt_xyz[:, 0]), max(cnt_xyz[:, 0])
    # min_y, max_y = min(cnt_xyz[:, 1]), max(cnt_xyz[:, 1])
    # # min_z, max_z = min(cnt_xyz[:, 2]), max(cnt_xyz[:, 2])
    # cell_z = cnt.get_cell()[2][2]

    # cell_x = [(max_x - min_x + cnt_gap), 0, 0]
    # cell_y = [0, (max_y - min_y + cnt_gap), 0]
    # cell_z = cnt.get_cell()[2]  # Use the lattice parameter Z of the CNT
    # system.set_cell([cell_x, cell_y, cell_z])

    # if system = surface:
    # do what you need to do

    # if system = crystal:
    # do what you need to do

    # if system = molecule:
    # do what you need to do
